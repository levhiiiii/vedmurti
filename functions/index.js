const functions = require('firebase-functions');
const admin = require('firebase-admin');

admin.initializeApp();

const db = admin.firestore();

// Cloud Function to automatically generate payouts on scheduled dates
exports.generateAutomaticPayouts = functions.pubsub.schedule('0 0 2,12,22 * *').timeZone('Asia/Kolkata').onRun(async (context) => {
  try {
    // Starting automatic payout generation
    
    // Get all users with KYC completed
    const usersSnapshot = await db.collection('users')
      .where('kycCompleted', '==', true)
      .get();
    
    let totalPayouts = 0;
    let totalAmount = 0;
    
    for (const userDoc of usersSnapshot.docs) {
      const userData = userDoc.data();
      const userId = userDoc.id;
      
      try {
        // Get user's primary bank account
        const bankAccountsSnapshot = await db.collection('bankAccounts')
          .where('userId', '==', userId)
          .where('isPrimary', '==', true)
          .limit(1)
          .get();
        
        if (bankAccountsSnapshot.empty) {
          // No primary bank account found for user
          continue;
        }
        
        const primaryAccount = bankAccountsSnapshot.docs[0].data();
        
        // Calculate total income from MLM data
        const mlmSnapshot = await db.collection('mlmUsers')
          .where('userId', '==', userId)
          .limit(1)
          .get();
        
        let totalIncome = 0;
        if (!mlmSnapshot.empty) {
          const mlmData = mlmSnapshot.docs[0].data();
          totalIncome = (mlmData.promotionalIncome || 0) + 
                       (mlmData.leadershipIncome || 0) + 
                       (mlmData.rewardsIncome || 0);
        }
        
        if (totalIncome > 0) {
          // Create payout record
          const payoutData = {
            userId: userId,
            userEmail: userData.email,
            userName: userData.name,
            userReferralCode: userData.referralCode,
            totalIncome: totalIncome,
            payoutAmount: totalIncome * 0.95, // 5% deduction
            deduction: totalIncome * 0.05,
            bankAccount: {
              accountHolderName: primaryAccount.accountHolderName,
              accountNumber: primaryAccount.accountNumber,
              bankName: primaryAccount.bankName,
              ifscCode: primaryAccount.ifscCode,
              branch: primaryAccount.branch
            },
            status: 'pending',
            payoutDate: admin.firestore.Timestamp.now(),
            generatedAt: admin.firestore.Timestamp.now(),
            payoutCycle: getCurrentPayoutCycle(),
            autoGenerated: true
          };
          
          // Save payout record
          const payoutRef = await db.collection('payouts').add(payoutData);
          
          // Reset user's income after payout generation
          if (!mlmSnapshot.empty) {
            const mlmDoc = mlmSnapshot.docs[0];
            await mlmDoc.ref.update({
              promotionalIncome: 0,
              leadershipIncome: 0,
              rewardsIncome: 0,
              dailyPairs: 0,
              dailyIncome: 0,
              lastPayoutDate: admin.firestore.Timestamp.now(),
              lastPayoutAmount: totalIncome
            });
          }
          
          totalPayouts++;
          totalAmount += payoutData.payoutAmount;
          
          // Generated payout for user
        }
      } catch (error) {
        console.error(`Error processing payout for user ${userId}:`, error);
      }
    }
    
    // Create payout summary
    const summaryData = {
      date: admin.firestore.Timestamp.now(),
      totalPayouts,
      totalAmount,
      totalDeductions: totalAmount * 0.05 / 0.95,
      payoutCycle: getCurrentPayoutCycle(),
      status: 'completed',
      autoGenerated: true
    };
    
    await db.collection('payoutSummaries').add(summaryData);
    
    // Automatic payout generation completed
    
    return { success: true, totalPayouts, totalAmount };
  } catch (error) {
    throw error;
  }
});

// Helper function to get current payout cycle
function getCurrentPayoutCycle() {
  const now = new Date();
  const month = now.getMonth() + 1;
  const year = now.getFullYear();
  const day = now.getDate();
  
  if (day <= 2) return `${year}-${month.toString().padStart(2, '0')}-01`;
  if (day <= 12) return `${year}-${month.toString().padStart(2, '0')}-02`;
  if (day <= 22) return `${year}-${month.toString().padStart(2, '0')}-03`;
  
  // If after 22nd, it's the next month's first cycle
  const nextMonth = month === 12 ? 1 : month + 1;
  const nextYear = month === 12 ? year + 1 : year;
  return `${nextYear}-${nextMonth.toString().padStart(2, '0')}-01`;
}

// HTTP function to manually trigger payout generation (for testing)
exports.manualPayoutGeneration = functions.https.onRequest(async (req, res) => {
  try {
    // Check if request is from admin (you can add authentication here)
    const { authorization } = req.headers;
    
    if (!authorization || authorization !== `Bearer ${functions.config().admin?.secret_key}`) {
      res.status(401).json({ error: 'Unauthorized' });
      return;
    }
    
    // Call the same logic as the scheduled function
    const result = await exports.generateAutomaticPayouts.run();
    
    res.json({
      success: true,
      message: 'Payout generation completed',
      result
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// HTTP function to get payout statistics
exports.getPayoutStatistics = functions.https.onRequest(async (req, res) => {
  try {
    const payoutsSnapshot = await db.collection('payouts').get();
    
    let totalPayouts = 0;
    let totalAmount = 0;
    let pendingPayouts = 0;
    let completedPayouts = 0;
    
    payoutsSnapshot.forEach((doc) => {
      const payout = doc.data();
      totalPayouts++;
      totalAmount += payout.payoutAmount || 0;
      
      if (payout.status === 'pending') {
        pendingPayouts++;
      } else if (payout.status === 'completed') {
        completedPayouts++;
      }
    });
    
    res.json({
      success: true,
      statistics: {
        totalPayouts,
        totalAmount,
        pendingPayouts,
        completedPayouts,
        averagePayout: totalPayouts > 0 ? totalAmount / totalPayouts : 0
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// HTTP function to update payout status
exports.updatePayoutStatus = functions.https.onRequest(async (req, res) => {
  try {
    const { payoutId, status, adminId } = req.body;
    
    if (!payoutId || !status) {
      res.status(400).json({ error: 'Missing required parameters' });
      return;
    }
    
    await db.collection('payouts').doc(payoutId).update({
      status: status,
      updatedAt: admin.firestore.Timestamp.now(),
      updatedBy: adminId || 'system'
    });
    
    res.json({
      success: true,
      message: 'Payout status updated successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
}); 

exports.deleteUser = functions.https.onCall(async (data, context) => {
  // Check if the request is from an admin
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
  }

  try {
    const { userId, userUid } = data;
    
    if (!userId || !userUid) {
      throw new functions.https.HttpsError('invalid-argument', 'User ID and UID are required');
    }

    // Delete from Firestore
    await admin.firestore().collection('users').doc(userId).delete();
    
    // Delete from Firebase Auth
    await admin.auth().deleteUser(userUid);
    
    return { success: true, message: 'User deleted successfully from both Firestore and Authentication' };
  } catch (error) {
    throw new functions.https.HttpsError('internal', 'Failed to delete user');
  }
}); 